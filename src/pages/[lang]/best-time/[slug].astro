---
import BaseLayout from '../../../layouts/BaseLayout.astro';
import '../../../styles/pages/best-time.css';
import '../../../styles/components/faq.css';
import '../../../styles/components/store-badges.css';
import '../../../styles/components/cross-links.css';
import StoreBadges from '../../../components/StoreBadges.astro';
import Breadcrumbs from '../../../components/Breadcrumbs.astro';
import RelatedLinks from '../../../components/RelatedLinks.astro';
import DataFreshness from '../../../components/DataFreshness.astro';
import citiesData from '../../../data/cities.json';
import { calculateKpBands, formatKpBands } from '../../../utils/kp-bands.ts';
import {
  buildBestTimeRelatedLinks,
  getCountrySlug,
  getPremiumDestinations,
  getSimilarCities
} from '../../../utils/cross-links.ts';
import type { CityRecord, StateBestTimeRecord } from '../../../utils/cross-links.ts';
import { normalizeStateSlug } from '../../../utils/slug-normalizer.ts';
import { appendBrand } from '../../../utils/geo-utils.ts';
import type { SupportedLanguage } from '@config/language-targeting';
import { SUPPORTED_LANGUAGES, getCitiesForLanguage } from '@config/language-targeting';
import { createPageI18n } from '../../../utils/i18n-page';
import { generatePageHreflangTags } from '../../../utils/hreflang';
import { getViewingQuality } from '../../../utils/viewing-quality.ts';
import { getSeasonalPatterns, getHourlyPatterns } from '../../../utils/seasonal-patterns.ts';

// Enable static generation for all best-time pages
export const prerender = true;

export async function getStaticPaths() {
  const paths = [];

  // Generate paths for each language
  for (const lang of SUPPORTED_LANGUAGES) {
    if (lang === 'en') continue; // English handled by original route

    // Get localized cities for this language
    const localizedCities = getCitiesForLanguage(citiesData as any, lang);
    const localizedCitySlugs = new Set(localizedCities.map(c => c.slug));

    // Generate best-time pages for localized cities only
    localizedCities.forEach(city => {
      paths.push({
        params: { lang, slug: city.slug },
        props: { lang, cityData: city, pageType: 'city' }
      });
    });

    // Generate best-time pages for states (only if they have localized cities)
    const statesMap = new Map();
    citiesData
      .filter(city => city.state && ['US', 'CA'].includes(city.countryCode))
      .forEach(city => {
        const stateISO = normalizeStateSlug(city.state, city.countryCode);
        if (!statesMap.has(stateISO)) {
          statesMap.set(stateISO, {
            slug: stateISO,
            name: city.state,
            country: city.country,
            countryCode: city.countryCode,
            cities: []
          });
        }
        statesMap.get(stateISO).cities.push(city);
      });

    statesMap.forEach((stateData) => {
      // Only generate if state has at least one localized city
      const hasLocalizedCities = stateData.cities.some(c => localizedCitySlugs.has(c.slug));
      if (hasLocalizedCities) {
        paths.push({
          params: { lang, slug: stateData.slug },
          props: { lang, cityData: stateData, pageType: 'state' }
        });
      }
    });
  }

  return paths;
}

const { lang, cityData, pageType = 'city' } = Astro.props;

if (!cityData) {
  throw new Error('Best-time page requires city or state data');
}
const isState = pageType === 'state';

// Initialize i18n (temporarily keeping English text, will add translations later)
const i18n = await createPageI18n(lang);

// Get localized cities for this language to build proper links
const localizedCitySlugs = new Set(
  getCitiesForLanguage(citiesData as any, lang).map(c => c.slug)
);

// Helper function to build city href (fallback to English if not localized)
const buildCityHref = (citySlug: string) => {
  return localizedCitySlugs.has(citySlug) ? `/${lang}/${citySlug}` : `/${citySlug}`;
};

// Helper function for best-time routes with localization fallback
const buildBestTimeHref = (slug: string) => {
  return localizedCitySlugs.has(slug) ? `/${lang}/best-time/${slug}` : `/best-time/${slug}`;
};

const localizeLinkHref = (href: string) => {
  if (!href.startsWith('/')) {
    return href;
  }

  if (href.startsWith(`/${lang}/`)) {
    return href;
  }

  if (href.startsWith('/best-time/')) {
    const slug = href.slice('/best-time/'.length);
    return buildBestTimeHref(slug);
  }

  if (href.startsWith('/country/')) {
    return `/${lang}${href}`;
  }

  const slug = href.slice(1);
  return buildCityHref(slug);
};

// Get location details
const locationName = cityData.name;
const magneticLat = isState
  ? Math.round(cityData.cities.reduce((sum, c) => sum + (c.magneticLat || 0), 0) / cityData.cities.length)
  : cityData.magneticLat;

const originSlug = `best-time/${cityData.slug}`;

const stateRecord: StateBestTimeRecord | null = isState
  ? {
      slug: cityData.slug,
      name: cityData.name,
      country: cityData.country,
      countryCode: cityData.countryCode,
      cities: cityData.cities ?? []
    }
  : null;

const primaryCity: CityRecord | null = isState
  ? (stateRecord?.cities.length
      ? [...stateRecord.cities].sort((a, b) => (b.magneticLat ?? 0) - (a.magneticLat ?? 0))[0]
      : null)
  : {
      slug: cityData.slug,
      name: cityData.name,
      country: cityData.country,
      countryCode: cityData.countryCode,
      magneticLat,
      state: cityData.state,
      description: cityData.description
    };

const relatedLinksSource = stateRecord ?? primaryCity;
const bestTimeRelatedLinks = relatedLinksSource
  ? buildBestTimeRelatedLinks(relatedLinksSource, lang).map(link => ({
      ...link,
      href: localizeLinkHref(link.href)
    }))
  : [];

const similarCities = primaryCity ? getSimilarCities(primaryCity, 3) : [];
const premiumDestinations = primaryCity ? getPremiumDestinations(primaryCity, 3) : getPremiumDestinations(undefined, 3);
const countrySlug = primaryCity ? getCountrySlug(primaryCity.country) : getCountrySlug(cityData.country);

// Use shared utility functions with i18n
const viewingQuality = getViewingQuality(primaryCity?.magneticLat ?? magneticLat, i18n);
const kpBands = calculateKpBands(magneticLat);
const seasonalPatterns = getSeasonalPatterns(magneticLat, i18n);
const topMonths = seasonalPatterns.slice(0, 3);
const challengingMonths = seasonalPatterns.filter(p => p.score < 50);
const hourlyPatterns = getHourlyPatterns(magneticLat, i18n);

// SEO optimization
const now = new Date();
const currentYear = now.getFullYear();
const seasonStartYear = now.getMonth() >= 6 ? currentYear : currentYear - 1;
const seasonEndYear = seasonStartYear + 1;
const seasonLabel = `${seasonStartYear}/${String(seasonEndYear).slice(-2).padStart(2, '0')}`;

const locationQualifier = cityData.country ? `${locationName}, ${cityData.country}` : locationName;
const titleBase = `${locationName} aurora season ${seasonLabel} ‚Äî best months`;
const pageTitle = appendBrand(titleBase);
const h1Title = `Best time to see the northern lights in ${locationQualifier}`;
const topMonthNames = topMonths.slice(0, 3).map((m) => m.month).join(', ');
const kpRange = formatKpBands(kpBands, 'range');
const pageDescription = `Plan your ${locationName} aurora trip: top months (${topMonthNames}), peak window ${hourlyPatterns.peak}, up to ${topMonths[0].darkness}h darkness, requires ${kpRange}.`;
const canonicalUrl = `https://auroraforecast.me/${lang}/best-time/${cityData.slug}`;

const buildCountryHref = (slug: string) => `/${lang}/country/${slug}`;

// Determine which languages actually have this best-time page
const localizedCitySets: Record<SupportedLanguage, Set<string>> = SUPPORTED_LANGUAGES.reduce((acc, code) => {
  const citiesForLang = code === 'en' ? (citiesData as any) : getCitiesForLanguage(citiesData as any, code);
  acc[code] = new Set(citiesForLang.map((c: any) => c.slug));
  return acc;
}, {} as Record<SupportedLanguage, Set<string>>);

const availableLanguages = SUPPORTED_LANGUAGES.filter(code => {
  if (code === 'en') return true;
  if (pageType === 'state' && Array.isArray((cityData as any).cities)) {
    return (cityData as any).cities.some((c: any) => localizedCitySets[code].has(c.slug));
  }
  return localizedCitySets[code].has(cityData.slug);
});

// Generate hreflang tags only for existing variants
const hreflangTags = generatePageHreflangTags(
  `/best-time/${cityData.slug}`,
  availableLanguages
);

// Breadcrumbs - fix state URLs to include country prefix and language
const stateUrl = isState ? buildBestTimeHref(cityData.slug) : buildCityHref(cityData.slug);
const breadcrumbs = [
  { title: i18n.t('breadcrumb_home', 'Home'), href: `/${lang}` },
  { title: locationName, href: stateUrl },
  { title: i18n.t('breadcrumb_best_time', 'Best Time') }
];

// Get current timestamp
const dataTimestamp = new Date().toISOString();
---

<BaseLayout
  title={pageTitle}
  description={pageDescription}
  canonical={canonicalUrl}
  lang={lang}
  hreflangTags={hreflangTags}
  i18n={i18n}
>
  <main class="container">
    <Breadcrumbs items={breadcrumbs} i18n={i18n} />

    <div class="best-time-header">
      <h1>{h1Title}</h1>
      <DataFreshness updatedAt={dataTimestamp} timezone="UTC" />
      <p class="intro">
        {i18n.tpl(i18n.t('bt_intro_based_on'), { mlat: magneticLat, location: locationName, start: topMonths[0].month, end: topMonths[2].month })}
        {' '}
        {i18n.tpl(i18n.t('bt_intro_peak_activity'), { month: topMonths[0].month, hours: topMonths[0].darkness })}
        {primaryCity && (
          <>
            {' '}
            <a
              class="cross-link-inline"
              href={buildCityHref(primaryCity.slug)}
              data-cross-link
              data-slot="intro"
              data-type="live"
              data-target={primaryCity.slug}
              data-position="1"
            >
              {i18n.tpl(i18n.t('bt_intro_check_forecast'), { city: primaryCity.name })}
            </a>
          </>
        )}
      </p>
    </div>

    <!-- Quick Stats -->
    <div class="quick-stats">
      <div class="stat-card">
        <h3>üëÅÔ∏è {i18n.t('bt_stat_viewing_quality')}</h3>
        <p class="stat-value">{viewingQuality.label}</p>
        <p class="stat-detail">
          {viewingQuality.description}
          {primaryCity && (
            <>
              {' '}
              <a
                class="cross-link-inline"
                href={buildCountryHref(countrySlug)}
                data-cross-link
                data-slot="quick_stat"
                data-type="compare"
                data-target={`country/${countrySlug}`}
                data-position="1"
              >
                {i18n.t('bt_compare_with')} {primaryCity.country}
              </a>
            </>
          )}
        </p>
      </div>
      <div class="stat-card">
        <h3>üåü {i18n.t('bt_stat_best_month')}</h3>
        <p class="stat-value">{topMonths[0].month}</p>
        <p class="stat-detail">{topMonths[0].reason}</p>
      </div>
      <div class="stat-card">
        <h3>üåô {i18n.t('bt_stat_peak_hours')}</h3>
        <p class="stat-value">{hourlyPatterns.peak}</p>
        <p class="stat-detail">{i18n.t('bt_stat_magnetic_midnight')}</p>
      </div>
      <div class="stat-card">
        <h3>‚ö° {i18n.t('bt_stat_required_kp')}</h3>
        <p class="stat-value">{formatKpBands(kpBands, 'range')}</p>
        <p class="stat-detail">{i18n.t('bt_stat_for_visibility')}</p>
      </div>
      <div class="stat-card">
        <h3>üåë {i18n.t('bt_stat_max_darkness')}</h3>
        <p class="stat-value">{topMonths[0].darkness}h</p>
        <p class="stat-detail">{i18n.t('bt_stat_in')} {topMonths[0].month}</p>
      </div>
    </div>

    <!-- Monthly Aurora Calendar -->
    <section class="monthly-calendar">
      <h2>{i18n.t('bt_section_activity_by_month')}</h2>
      <div class="calendar-chart">
        {seasonalPatterns.map((pattern) => (
          <div class={`month-bar score-${Math.floor(pattern.score / 20) * 20}`}>
            <div class="month-header">
              <div class="month-label">{pattern.month}</div>
              <div class="activity-bar">
                <div
                  class={`bar-fill score-${Math.floor(pattern.score / 20) * 20}`}
                  style={`width: ${pattern.score}%`}
                >
                  <span class="score">{pattern.score}%</span>
                </div>
              </div>
            </div>
            <div class="month-details">
              <span class="darkness-hours">{i18n.tpl(i18n.t('bt_calendar_hours_dark'), { hours: pattern.darkness })}</span>
              <span class="reason">{pattern.reason}</span>
            </div>
            {pattern.highlights && pattern.highlights.length > 0 && (
              <div class="month-highlights">
                {pattern.highlights.map(highlight => (
                  <div class="highlight-item">
                    <span class="highlight-bullet">‚Ä¢</span>
                    <span class="highlight-text">{highlight}</span>
                  </div>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>
    </section>

    <!-- Top Viewing Months Details -->
    <section class="top-months">
      <h2>{i18n.tpl(i18n.t('bt_peak_aurora_months'), { location: locationName })}</h2>
      <div class="months-grid">
        {topMonths.map((month, index) => (
          <div class={`month-card rank-${index + 1}`}>
            <div class="month-header">
              <h3>{month.month}</h3>
              <span class="activity-badge">{month.score}% activity</span>
            </div>
            <p class="month-reason">{month.reason}</p>
            <ul class="month-highlights">
              {month.highlights.map(highlight => (
                <li>{highlight}</li>
              ))}
            </ul>
            <div class="month-stats">
              <span class="darkness-stat">üåë {month.darkness}h darkness</span>
              <span class="kp-stat">‚ö° Kp {kpBands.horizon.toFixed(1)}+ needed</span>
            </div>
            {index === 0 && similarCities.length > 0 && (
              <p class="month-related">
                {i18n.t('bt_compare_similar')}:
                {similarCities.map((city, idx) => (
                  <span>
                    {idx > 0 ? ', ' : ' '}
                    <a
                      class="cross-link-inline"
                      href={buildBestTimeHref(city.slug)}
                      data-cross-link
                      data-slot="best_month"
                      data-type="guide"
                      data-target={`best-time/${city.slug}`}
                      data-position={`${idx + 1}`}
                    >
                      {city.name}
                    </a>
                  </span>
                ))}
              </p>
            )}
          </div>
        ))}
      </div>
    </section>

    <!-- Hourly Patterns -->
    <section class="hourly-patterns">
      <h2>{i18n.t('bt_section_best_time_night')}</h2>
      <div class="time-visualization">
        <div class="clock-diagram">
          <div class="time-blocks">
            {[18,19,20,21,22,23,0,1,2,3,4,5,6].map(hour => (
              <div class={`hour-block ${(hour >= 22 || hour <= 2) ? 'peak' : (hour >= 21 || hour <= 3) ? 'good' : 'low'}`}>
                <span class="hour">{hour}:00</span>
                <div class="activity-indicator"></div>
              </div>
            ))}
          </div>
        </div>
        <div class="time-explanation">
          <h3>{i18n.t('bt_peak_hours_title')} {hourlyPatterns.peak}</h3>
          <p>{hourlyPatterns.description}</p>
          <h4>{i18n.t('bt_why_hours_title')}</h4>
          <ul>
            {hourlyPatterns.factors.map(factor => (
              <li>{factor}</li>
            ))}
          </ul>
        </div>
      </div>
    </section>

    <!-- Seasonal Breakdown -->
    <section class="seasonal-breakdown">
      <h2>{i18n.t('bt_section_seasonal_guide')}</h2>
      <div class="seasons-grid">
        <div class="season-card autumn">
          <h3>üçÇ {i18n.t('bt_season_autumn')}</h3>
          <div class="season-score">{i18n.t('bt_season_badge_best')}</div>
          <p>{i18n.t('bt_autumn_desc')}</p>
          <ul>
            <li>{i18n.t('bt_autumn_li1')}</li>
            <li>{i18n.t('bt_autumn_li2_darkness')} {magneticLat > 60 ? '14-18' : '10-12'} {i18n.t('bt_autumn_li2_hours')}</li>
            <li>{i18n.t('bt_autumn_li3')}</li>
          </ul>
        </div>

        <div class="season-card winter">
          <h3>‚ùÑÔ∏è {i18n.t('bt_season_winter')}</h3>
          <div class="season-score">{i18n.t('bt_season_badge_max_darkness')}</div>
          <p>{i18n.t('bt_winter_desc')}</p>
          <ul>
            <li>{i18n.t('bt_winter_li1_darkness')} {magneticLat > 65 ? '20' : magneticLat > 55 ? '15-17' : '12-14'} {i18n.t('bt_winter_li1_hours')}</li>
            <li>{i18n.t('bt_winter_li2')}</li>
            <li>{i18n.t('bt_winter_li3')}</li>
          </ul>
        </div>

        <div class="season-card spring">
          <h3>üå∏ {i18n.t('bt_season_spring')}</h3>
          <div class="season-score">{i18n.t('bt_season_badge_equinox')}</div>
          <p>{i18n.t('bt_spring_desc')}</p>
          <ul>
            <li>{i18n.t('bt_spring_li1')}</li>
            <li>{i18n.t('bt_spring_li2')}</li>
            <li>{i18n.t('bt_spring_li3')}</li>
          </ul>
        </div>

        <div class="season-card summer">
          <h3>‚òÄÔ∏è {i18n.t('bt_season_summer')}</h3>
          <div class="season-score">{i18n.t('bt_season_badge_challenging')}</div>
          <p>{magneticLat > 66
            ? i18n.t('bt_summer_desc_polar')
            : i18n.t('bt_summer_desc_normal')
          }</p>
          <ul>
            <li>{i18n.t('bt_summer_li1_darkness')} {magneticLat > 66 ? '0-4' : '4-8'} {i18n.t('bt_summer_li1_hours')}</li>
            <li>{i18n.t('bt_summer_li2')}</li>
            <li>{i18n.t('bt_summer_li3')}</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Planning Tips -->
    <section class="planning-tips">
      <h2>{i18n.t('bt_section_planning_trip_to')}</h2>
      <div class="tips-grid">
        <div class="tip-card">
          <h3>üìÖ {i18n.t('bt_plan_booking')}</h3>
          <ul>
            <li>{i18n.t('bt_book_for')} {topMonths[0].month} {i18n.t('bt_booking_li1_or')} {topMonths[1].month} {i18n.t('bt_booking_li1_for')}</li>
            <li>{i18n.t('bt_booking_li2')}</li>
            <li>{i18n.t('bt_booking_li3')}</li>
            <li>{i18n.t('bt_booking_li4')}</li>
          </ul>
        </div>

        <div class="tip-card">
          <h3>üå°Ô∏è {i18n.t('bt_plan_weather')}</h3>
          <ul>
            <li>{i18n.t('bt_weather_li1')}</li>
            <li>{magneticLat > 60 ? i18n.t('bt_weather_li2_arctic') : i18n.t('bt_weather_li2_coastal')}</li>
            <li>{i18n.t('bt_weather_li3')}</li>
            <li>{i18n.t('bt_weather_li4')}</li>
          </ul>
        </div>

        <div class="tip-card">
          <h3>üì∏ {i18n.t('bt_plan_photography')}</h3>
          <ul>
            <li>{i18n.t('bt_photo_li1')}</li>
            <li>{i18n.t('bt_photo_li2')}</li>
            <li>{i18n.t('bt_photo_li3')}</li>
            <li>{i18n.t('bt_photo_li4_arrive')} {hourlyPatterns.good.split('-')[0]} {i18n.t('bt_photo_li4_setup')}</li>
          </ul>
        </div>

        <div class="tip-card">
          <h3>üéØ {i18n.t('bt_plan_success')}</h3>
          <ul>
            <li>{i18n.t('bt_success_li1_kp')} {kpBands.horizon.toFixed(1)}+</li>
            <li>{i18n.t('bt_success_li2_awake')} {hourlyPatterns.peak}</li>
            <li>{i18n.t('bt_success_li3')}</li>
            <li>{i18n.t('bt_success_li4')}</li>
          </ul>
          {premiumDestinations.length > 0 && (
          <p class="tip-related">
            {i18n.t('bt_tip_guaranteed_shows')}
            {premiumDestinations.slice(0, 3).map((city, idx) => (
              <span>
                {idx > 0 ? ', ' : ' '}
                <a
                  class="cross-link-inline"
                  href={buildBestTimeHref(city.slug)}
                  data-cross-link
                  data-slot="planning"
                  data-type="premium"
                  data-target={`best-time/${city.slug}`}
                  data-position={`${idx + 1}`}
                  >
                    {city.name}
                  </a>
                </span>
              ))}
            </p>
          )}
        </div>
      </div>
    </section>

    <!-- FAQ Section -->
    <section class="faq-section faq-section--wide best-time-faq">
      <h2>{i18n.t('bt_section_faq')}</h2>
      <div class="faq-grid">
        <div class="faq-item faq-theme-primary">
          <h3>{i18n.tpl(i18n.t('bt_faq_q1_best_month'), { location: locationName })}</h3>
          <p>
            {i18n.tpl(i18n.t('bt_faq_a1_best_month'), { month: topMonths[0].month, score: topMonths[0].score, hours: topMonths[0].darkness })}
          </p>
        </div>

        <div class="faq-item faq-theme-secondary">
          <h3>{i18n.tpl(i18n.t('bt_faq_q2_summer'), { location: locationName })}</h3>
          <p>
            {magneticLat > 66
              ? i18n.t('bt_faq_a2_summer_polar')
              : i18n.tpl(i18n.t('bt_faq_a2_summer_normal'), { hours: challengingMonths.find(m => m.month === 'June')?.darkness || 4 })
            }
          </p>
        </div>

        <div class="faq-item faq-theme-tertiary">
          <h3>{i18n.t('bt_faq_q4_time')}</h3>
          <p>
            {i18n.t('bt_faq_window_start')} {hourlyPatterns.peak} {i18n.t('bt_faq_window_local')} {hourlyPatterns.good.split('-')[0]}
            {i18n.t('bt_faq_window_until')} {hourlyPatterns.good.split('-')[1]} {i18n.t('bt_faq_window_end')}
          </p>
        </div>

        <div class="faq-item faq-theme-primary">
          <h3>{i18n.t('bt_faq_q3_nights')}</h3>
          <p>
            {i18n.tpl(i18n.t('bt_faq_a3_nights'), { location: locationName, month1: topMonths[0].month, month2: topMonths[1].month, kp: kpBands.horizon.toFixed(1) })}
          </p>
        </div>
      </div>
    </section>

    <!-- Call to Action -->
    <section class="cta-app">
      <h2>{i18n.t('bt_section_never_miss')}</h2>
      <p>{i18n.tpl(i18n.t('bt_cta_alerts'), { location: locationName })}
         {' '}
         {i18n.t('bt_cta_track')}</p>
      <StoreBadges
        pageType="best_time"
        citySlug={cityData.slug}
        placement="cta"
        enhanced={true}
        size="large"
      />
      {primaryCity && (
        <p class="cta-secondary">
          <a
            class="cross-link-inline"
            href={buildCountryHref(countrySlug)}
            data-cross-link
            data-slot="cta"
            data-type="guide"
            data-target={`country/${countrySlug}`}
            data-position="1"
          >
            {i18n.tpl(i18n.t('bt_cta_explore_destinations'), { country: primaryCity.country })}
          </a>
        </p>
      )}
    </section>

    <RelatedLinks
      title={i18n.t('bt_related_resources')}
      links={bestTimeRelatedLinks}
      originSlug={originSlug}
      slot="related_block"
      i18n={i18n}
    />
  </main>

  <!-- Schema.org markup -->
  <script
    type="application/ld+json"
    set:html={JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'TravelGuide',
      'name': `Best Time to See Northern Lights in ${locationName}`,
      'description': pageDescription,
      'about': {
        '@type': 'Thing',
        'name': 'Aurora Borealis',
        'alternateName': 'Northern Lights'
      },
      'temporalCoverage': topMonths.map(m => m.month).join('/'),
      'spatialCoverage': {
        '@type': 'Place',
        'name': locationName,
        'geo': cityData.lat
          ? {
              '@type': 'GeoCoordinates',
              'latitude': cityData.lat,
              'longitude': cityData.lon
            }
          : undefined
      },
      'mainEntity': {
        '@type': 'FAQPage',
        'mainEntity': [
          {
            '@type': 'Question',
            'name': `What is the best month to see aurora in ${locationName}?`,
            'acceptedAnswer': {
              '@type': 'Answer',
              'text': `${topMonths[0].month} is the best month with ${topMonths[0].score}% activity rate and ${topMonths[0].darkness} hours of darkness.`
            }
          },
          {
            '@type': 'Question',
            'name': `What time should I look for northern lights in ${locationName}?`,
            'acceptedAnswer': {
              '@type': 'Answer',
              'text': `${i18n.t('bt_faq_window_start')} ${hourlyPatterns.peak} ${i18n.t('bt_faq_window_local')} ${hourlyPatterns.good.split('-')[0]} ${i18n.t('bt_faq_window_until')} ${hourlyPatterns.good.split('-')[1]} ${i18n.t('bt_faq_window_end')}`
            }
          }
        ]
      }
    })}
  ></script>

  <script type="module">
  import { trackCrossLink } from '../../../utils/analytics-helper.js';

    const originSlug = `${originSlug}`;

    document.querySelectorAll('[data-cross-link]').forEach((anchor) => {
      anchor.addEventListener('click', () => {
        const slot = anchor.getAttribute('data-slot') ?? 'related_block';
        const target = anchor.getAttribute('data-target') ?? '';
        const type = (anchor.getAttribute('data-type') ?? 'guide');
        const positionAttr = Number(anchor.getAttribute('data-position') ?? '1');
        const position = Number.isNaN(positionAttr) ? 1 : positionAttr;

        trackCrossLink({
          slot,
          originSlug,
          targetSlug: target,
          linkType: type,
          position
        });
      });
    });
  </script>
</BaseLayout>
